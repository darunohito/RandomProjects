<?php
namespace Jengascoin\Miner;
require('blake3_optimized.php');
use BLAKE3;

ini_set("memory_limit", "8G");
$NUM_BITS = 512

// See https://github.com/ethereum/wiki/wiki/Dagger-Hashimoto#dagger-graph-building

$SAFE_PRIME_512 = 2**512 - 38117     # Largest Safe Prime less than 2**512
class Miner
{
	public const Gb = 999948288 * 8; // NUM_BITS per gigabit, multiple of 65536
	public const n = 4000055296 * 8; // NUM_BITS,  # Size of the dataset (4 Gigabytes); MUST BE MULTIPLE OF 65536
    public const n_inc = 65536;                   # Increment in value of n per period; MUST BE MULTIPLE OF 65536 
	#with epochtime=20000 gives 882 MB growth per year
    private $cache_size;               # Size of the light client's cache (can be chosen by light client; not part of the algo spec)
    private $diff;                    # Difficulty (adjusted during block evaluation)
    private $epochtime;              # Length of an epoch in blocks (how often the dataset is updated)
    private $k;                          # Number of parents of a node
    private $w;                         # Used for modular exponentiation hashing
    private $accesses;                 # Number of dataset accesses during hashimoto
    public const P = strval($SAFE_PRIME_512);              # Safe Prime for hashing and random number generation
	private $prime; # Experimental prime value, not yet implemented
	
	//from old miner
	private $publicKey;
    private $privateKey;
    private $speed;
    private $avgSpeed;
    private $node;
    private $block;
    //private $difficulty; replace with $diff
    private $counter;
    private $allTime;
    private $beginTime;
    private $type;
    private $worker;
    private $lastUpdate;
    private $submit;
    private $confirm;
    private $found;
    private $height;
    private $testnet;
	  
	/**
     * miner constructor.
     *
     * @param $type
     * @param $node
     * @param $public_key
     * @param $private_key
     */
    public function __construct($type, $size, $node, $public_key, $private_key)
    {	
		$this->outputHeader();
		$this->checkDependencies();
		
		if (empty($type) || empty($size) || empty($public_key) || empty($node) || ($type == self::MODE_SOLO && empty($private_key))) {
            echo "Usage:

For Solo mining: ./miner solo <size_in_GB> <node> <public_key> <private_key>

For Pool mining: ./miner pool <size_in_GB> <pool-address> <your-address>\n\n";
            exit;
        }
		if ((log($size,2) % 1) != 0) {
			$size = 2^(floor(log($size,2)))
			echo "DAG size rounded down to nearest power of 2\n";
		}
			
		if ($type == self::MODE_POOL) {
            $private_key = $public_key;
        }
		
		$worker = uniqid();
		
		prepare($public_key, $private_key, $node, $type, $worker, $size);
		
		$pt_r = file_get_contents("http://pool.jengas.io/pt.php");
		if($pt_r > 0)
		{
			//echo "PT_R $pt_r\n";
			$pt = $pt_r;
		}
		
		$res = $this->update();
		if (!$res) {
			die("ERROR: Could not get mining info from the node\n");
		}
		
		$base = $this->publicKey."-".$nonce."-".$this->block."-".$this->diff;
		$dagger = produce_dag($base,bcmul($this->size,strval(Gb)));
		
		$nonce = mine($dagger);
		echo "nonce found: $nonce\n";
	}
	
	/**
     * @param string $publicKey
     * @param string $privateKey
     * @param string $node
     * @param string $type
     * @param string $worker
     */
    public function prepare(string $publicKey, string $privateKey, string $node, string $type, string $worker, int $size)
    {
        $this->publicKey = $publicKey;
        $this->privateKey = $privateKey;
        $this->node = $node;
        $this->type = $type;
        $this->worker = $worker;
        $this->counter = 0;
        $this->submit = 0;
        $this->confirm = 0;
        $this->found = 0;
		
		// ethash stuff
		$this->size = $size;
		$this->diff = 2**14;
		$this->epochtime = 100000;
		$this->accesses = 200; 
		$this->cache_size =  = 2500;
		$this->k = 1; 
		$this->w = w; 
    }
	
	/**
     * Output the miner header text.
     */
    public function outputHeader()
    {
        echo "########################\n";
        echo "# Jengascoin DAG miner #\n";
        echo "# www.jengas.io        #\n";
        echo "########################\n";
    }
	
	/**
     * Check for the required dependencies.
     */
    public function checkDependencies()
    {
        if (!extension_loaded("gmp")) {
            die("The GMP PHP extension is missing.");
        }

        if (!extension_loaded("openssl")) {
            die("The OpenSSL PHP extension is missing.");
        }

        if (floatval(phpversion()) < 7.2) {
            die("The minimum PHP version required is 7.2.");
        }
    }
	
	public function produce_dag(string $seed, integer $length) 
	{
		$b3 = new BLAKE3();
		$picker = $init = bcpowmod($b3->hash($seed,'64'), $this->w, P);
		$o = $init;
			
		for($i=1; $i<$length; $i++) {
			// $x = $picker = ($picker * $init) % P
			$x = $picker = bcmod(bcmul($picker,$init),P)
			for($i2=0; $i2++; $i2<$this->k) {
				$x ^= $o[(int)(bcmod($x,strval($i)))];
			}
			$o .= bcpowmod($x, strval($this->w), P));
		}
		return $o;
	}
	
	
	public function mine($daggerset) 
	{
		// nonce = randint(0, 2**64)
		$nonces_tried = 0;
		$nonce = base64_encode(openssl_random_pseudo_bytes(16));
		while (1) 
		{
			//$result = hashimoto($daggerset, get_dagsize(params, block),params, decode_int(block.prevhash), $nonce);
			$result = hashimoto($daggerset, bcmul($this->size,strval(Gb)),$this->block, $nonce);
			if (bccomp(bcmul($result,$this->diff),strval(2**256)) <= 0) {
				break;
			}
			$nonce = bcadd($nonce,1);
			if (bccomp($nonce,strval(2**64)) > 0) {
				$nonce = 0;
			}
			$nonces_tried++;
			if(mod($nonces_tried,10) == 0)
				echo "10 more nonces tried\n"
			endif
		}
		return $nonce;
	}
	
	public function hashimoto($dag, $dagsize, $header, $nonce) 
	{
		$m = strval(floor($dagsize / 2));
		$b3 = new BLAKE3();
		$mix = $b3->hash($nonce.$header,'64');
		for($i=0; $i<$this->accesses; $i++) {
			//mix ^= dag[m + (mix % 2**64) % m]
			$mix = gmp_xor($mix,$dag[bcadd($m,bcmod((bcmod($mix,strval(2**64))),$m))]
		}
		return $b3->hash($b3->hash(mix,'64'),'64');
	}
	
	public function verify($daggerset, $block, $nonce) {
    $result = hashimoto($daggerset, bcmul($this->size,strval(Gb)),
                       decode_int(block.prevhash), $nonce)
    return bccomp(bcmul($result,$this->diff), strval(2**256))
	
	/**
     * @return bool
     */
    public function update(): bool
    {
		global $noshare_time;
		global $pooltarget;
		global $pt;
		global $outp;
		global $dbg;
        $this->lastUpdate = time();

        $extra = "";
        if ($this->type == self::MODE_POOL) {
            $extra = "&worker=".$this->worker."&address=".$this->privateKey."&hashrate=".$this->speed;
			$res = file_get_contents($this->node."/mine.php?q=info".$extra);	
		} else {
			$res = file_get_contents($this->node."/api.php?q=getMiningInfo".$extra);		
        }
		$info = json_decode($res, true);
        if ($info['status'] != self::NODE_STATUS_OK) {
            return false;
        }

        $data = $info['data'];
        $this->block = $data['block'];
        $this->difficulty = $data['difficulty'];
		
        if ($this->type === self::MODE_POOL) {
            $this->publicKey = $data['public_key'];
        }

        $this->height = $data['height'];
        $max_target = bchexdec('0x00000000FFFF0000000000000000000000000000000000000000000000000000');
		$target = bcsub($max_target, $this->difficulty);
		if(!isset($pooltarget))
		{
			$pooltarget = bcmul($target, "$pt");
		}
		if ($target < 1) {	
			$target = 1;
		}

		if ($this->type == self::MODE_POOL) {
			if(isset($this->best))
			{
				$b[] = "\n--> Best Hash  : ".number_format($this->best, 0, '.', '');
			} else {
				$b[] = "\n--> Best Hash  : 0";
			}
			$b[] = "\n--> Target     : $target";
			$b[] = "\n--> Pool Target: $pooltarget";
			$b[] = "\n--> Difficulty : ".$this->difficulty;
			$b[] = $outp;
			$b[] = $dbg;
		} else {
			$b[] = "\n--> Target     : $target";
			$b[] = "\n--> Difficulty : ".$this->difficulty;
			$b[] = $outp;
			$b[] = $dbg;
		}
		
		replaceCommandOutput($b);
		if(isset($dbg)) { unset($dbg); }
		unset($b);
        return true;
    }
}


/*
public function quick_calc(string $seed, integer $p) 
{
$w = $this->w;
$cache = {};
	public function quick_calc_cached(integer $p) 
	{
		if (!empty($cache[$p])) {
			break;
		}
		elseif ($p == 0) {
			$b3 = new BLAKE3();
			$cache[$p] = bcpowmod($b3->hash($seed), strval($this->w), P);
		}
		else {
			$b3 = new BLAKE3();
			$x = bcpowmod($b3->hash($seed), strval(($p + 1) * $this->w), P);
			for($i2=0; $i2++; $i2<$this->k) {
				$x = gmp_xor($x,quick_calc_cached(bcmod($x,strval($p))));
			}
			cache[$p] = bcpowmod($x, $this->w, P)
		}
		return cache[$p];
	}
return quick_calc_cached($p);
}

function get_prevhash(n) {
    from pyethereum.blocks import GENESIS_PREVHASH 
    from pyethreum import chain_manager
    if num <= 0 {
        return hash_to_int(GENESIS_PREVHASH)
    else {
        prevhash = chain_manager.index.get_block_by_number(n - 1)
        return decode_int(prevhash)

function get_seedset(params, block) {
    seedset = {}
    seedset["back_number"] = block.number - (block.number % params["epochtime"])
    seedset["back_hash"] = get_prevhash(seedset["back_number"])
    seedset["front_number"] = max(seedset["back_number"] - params["epochtime"], 0)
    seedset["front_hash"] = get_prevhash(seedset["front_number"])
    return seedset

function get_dagsize(params, block) {
    return params["n"] + (block.number // params["epochtime"]) * params["n_inc"]

function get_daggerset(params, block) {
    dagsz = get_dagsize(params, block)
    seedset = get_seedset(params, block)
    if seedset["front_hash"] <= 0 {
        # No back buffer is possible, just make front buffer
        return {"front": {"dag": produce_dag(params, seedset["front_hash"], dagsz), 
                          "block_number": 0}}
    else {
        return {"front": {"dag": produce_dag(params, seedset["front_hash"], dagsz),
                          "block_number": seedset["front_number"]},
                "back": {"dag": produce_dag(params, seedset["back_hash"], dagsz),
                         "block_number": seedset["back_number"]}}

function quick_hashimoto(seed, dagsize, params, header, nonce) {
    m = dagsize // 2
    mix = sha3(nonce + header)
    for() _ in range(params["accesses"]) {
        mix ^= quick_calc(params, seed, m + (mix % 2**64) % m)
    return dbl_sha3(mix)



function verify(daggerset, params, block, nonce) {
    result = hashimoto(daggerset, get_dagsize(params, block),
                       params, decode_int(block.prevhash), nonce)
    return result * params["diff"] < 2**256

function light_verify(params, header, nonce) {
    seedset = get_seedset(params, block)
    result = quick_hashimoto(seedset["front_hash"], get_dagsize(params, block),
                             params, decode_int(block.prevhash), nonce)
    return result * params["diff"] < 2**256
*/
    /**
     * @param array $source
     * @param mixed $source_base
     * @param mixed $target_base
     * @return array
     *
     * @author Mika Tuupola
     * @link   https://github.com/tuupola/base58
     */
    public function baseConvert(array $source, $source_base, $target_base)
    {
        $result = [];
        while ($count = count($source)) {
            $quotient = [];
            $remainder = 0;
            for ($i = 0; $i !== $count; $i++) {
                $accumulator = $source[$i] + $remainder * $source_base;
                $digit = (integer)($accumulator / $target_base);
                $remainder = $accumulator % $target_base;
                if (count($quotient) || $digit) {
                    array_push($quotient, $digit);
                };
            }
            array_unshift($result, $remainder);
            $source = $quotient;
        }
        return $result;
    }

    /**
     * @param mixed $data
     * @param bool  $integer
     * @return int|string
     *
     * @author Mika Tuupola
     * @link   https://github.com/tuupola/base58
     */
    public function base58Decode($data, $integer = false)
    {
        $data = str_split($data);
        $data = array_map(function ($character) {
            $chars = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
            return strpos($chars, $character);
        }, $data);
        /* Return as integer when requested. */
        if ($integer) {
            $converted = $this->baseConvert($data, 58, 10);
            return (integer)implode("", $converted);
        }
        $converted = $this->baseConvert($data, 58, 256);
        return implode("", array_map(function ($ascii) {
            return chr($ascii);
        }, $converted));
    }

    /**
     * Check for the required dependencies.
     */
    public function checkDependencies()
    {
        if (!extension_loaded("gmp")) {
            die("The GMP PHP extension is missing.");
        }

        if (!extension_loaded("openssl")) {
            die("The OpenSSL PHP extension is missing.");
        }

        if (floatval(phpversion()) < 7.2) {
            die("The minimum PHP version required is 7.2.");
        }
    }

    /**
     * Output the miner header text.
     */
    public function outputHeader()
    {
        echo "######################\n";
        echo "# Jengascoin Miner   #\n";
        echo "# www.jengas.io      #\n";
        echo "######################\n";
    }

}
// BCmath version for huge numbers
function bc_arb_encode($num, $basestr) {
    if( ! function_exists('bcadd') ) {
        Throw new Exception('You need the BCmath extension.');
    }

    $base = strlen($basestr);
    $rep = '';

    while( true ){
        if( strlen($num) < 2 ) {
            if( intval($num) <= 0 ) {
                break;
            }
        }
        $rem = bcmod($num, $base);
        $rep = $basestr[intval($rem)] . $rep;
        $num = bcdiv(bcsub($num, $rem), $base);
    }
    return $rep;
}

function bc_arb_decode($num, $basestr) {
    if( ! function_exists('bcadd') ) {
        Throw new Exception('You need the BCmath extension.');
    }

    $base = strlen($basestr);
    $dec = '0';

    $num_arr = str_split((string)$num);
    $cnt = strlen($num);
    for($i=0; $i < $cnt; $i++) {
        $pos = strpos($basestr, $num_arr[$i]);
        if( $pos === false ) {
            Throw new Exception(sprintf('Unknown character %s at offset %d', $num_arr[$i], $i));
        }
        $dec = bcadd(bcmul($dec, $base), $pos);
    }
    return $dec;
}
//hexdec with BCmath
function bc_hexdec($num) {
    return bc_arb_decode(strtolower($num), '0123456789abcdef');
}
function bc_dechex($num) {
    return bc_arb_encode($num, '0123456789abcdef');
}
function bchexdec($hex)
{
	$dec = 0;
    $len = strlen($hex);
    for ($i = 1; $i <= $len; $i++)
        $dec = bcadd(strval($dec), bcmul(strval(hexdec($hex[$i - 1])), bcpow('16', strval($len - $i))));
   
    return $dec;
}